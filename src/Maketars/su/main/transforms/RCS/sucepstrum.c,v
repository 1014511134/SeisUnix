head	1.7;
access;
symbols;
locks
	john:1.7; strict;
comment	@ * @;


1.7
date	2011.11.16.23.35.04;	author john;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.12.00.42.19;	author john;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.07.00.13.05;	author john;	state Exp;
branches;
next	1.4;

1.4
date	2010.11.24.22.51.47;	author john;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.28.17.19.20;	author john;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.22.17.41.35;	author john;	state Exp;
branches;
next	1.1;

1.1
date	2008.08.01.18.39.56;	author john;	state Exp;
branches;
next	;


desc
@cepstrum of a seismic panel
@


1.7
log
@added Reg Beardsley's checkpar()
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUCEPSTRUM: $Revision: 1.5 $ ; $Date: 2010/12/07 00:13:05 $	*/

#include "su.h"
#include "segy.h"
#include "header.h"
#define TWOPI 2.0*PI
#define TINY FLT_EPSILON
#define CTINY cmplx(FLT_EPSILON,FLT_EPSILON)

/*********************** self documentation *****************************/
char *sdoc[] = {
" SUCEPSTRUM - Compute the CEPSTRUM of a seismic trace or compute the	",
"		minimum phase reconstruction of a trace			",
"  sucepstrum < stdin > stdout					   	",
"									",
" Required parameters:						  	",
"	none								",
" Optional parameters:						  	",
" sign1=1		sign of real to complex transform		",
" sign2=1		sign of complex to real transform		",
"   mpr=0		=1 minimum phase reconstructed version of	", 
"			    original signal				",
"   centered=0		=1 symmetrical output			 	",
" Notes:								",
" The cepstrum is defined as the fourier transform of the the decibel   ",
" spectrum, as though it were a time domain signal.			",
" C(t) = FFT(ln(|T(w)|)}						",
"	|T(w)| = amplitude spectrum of the trace			",
" For mpr=1, the input traces are converted to the minimum phase form.	",
NULL};

/*
 * Author: Balazs Nemeth of Potash Corporation of Saskatchewan Inc. 
 *  given to CWP in 2008
 *
 */
/**************** end self doc ********************************/

#define LOOKFAC 4	/* Look ahead factor for npfaro   */
#define PFA_MAX 720720  /* Largest allowed nfft	   */

/* Segy data constants */
segy tr;				/* SEGY trace */
segy trout;

void rceps(int sign1, int sign2, int nt, int mph,float *x,float *c);

int 
main( int argc, char *argv[] )
{
	int nt;		/* number of time samples per trace		*/
	float dt;	/* time sampling interval			*/
	int centered;	/* flag; =1 symmetric output 			*/
	int mpr;	/* flag: =1 perform minimum phase reconstruction*/
	int sign1;	/* sign on real to complex transform		*/
	int sign2;	/* sign on complex to real transform		*/
	
	/* hook up getpars */
	initargs(argc, argv);
   	requestdoc(1);	
	
	/* get parameters */
	if (!getparint("centered", &centered)) centered=0;
	if (!getparint("mpr", &mpr))		mpr=0;
	if (!getparint("sign1",&sign1)) 	sign1=1;
	if (!getparint("sign2",&sign2)) 	sign2=1;
	

        checkpars();

	/* get information from the first header */
	if (!gettr(&tr)) err("can't get first trace");
	nt = tr.ns;
	dt = (double)tr.dt/1000000.0;
		
	/* loop over traces */
	do {

			/* compute the cepstrum or compute	*/
			/* minimum phase reconstruction		*/
			rceps(sign1,sign2,nt,mpr,tr.data,tr.data);	
			
			/* computation if centered output desired */
			if(centered) {
				{ int n,it;
					if(!ISODD(nt)) {
						n=nt+1;
					} else {
						n=nt;
					}
					memcpy((void *) &trout,(const void *) &tr,HDRBYTES);
					memcpy((void *) &trout.data[n/2],(const void *) tr.data,n/2*FSIZE);
					for(it=0;it<n/2;it++) 
						trout.data[it] = tr.data[n/2-it];
					trout.ns=n;
					trout.f1=-n/2*dt;
					trout.d1=dt;
					puttr(&trout);
				}
			} else {
				puttr(&tr);
			}
	} while(gettr(&tr));
	
	return(CWP_Exit());
}

void rceps(int sign1,int sign2,int nt, int mph,float *x,float *c)
/***********************************************************************
rceps - compute the cepstrum or the minimum phase reconstruction of a signal
        using the cepstrum.
************************************************************************
Input:
nt	number of time samples
mph	minimum phase reconstruction flag
x	input data
Output:
c	output data
************************************************************************
Author: Balasz Nemeth, Potash Corporation, Saskatchewan  c. 2008
***********************************************************************/
{	
	int nfftc;
	int nf;
	float snfftc;
	complex *w=NULL;
	float *a=NULL;
	float *p=NULL;
	int iw;
	int ntp;
	
	
	/* Set up pfa fft */
	ntp = NINT(nt);
	nfftc = npfao(ntp,LOOKFAC*ntp); 
	if (nfftc >= SU_NFLTS || nfftc >= PFA_MAX)
			err("Padded nt=%d--too big", nfftc);
	nf = nfftc/2 + 1;
	snfftc=1.0/nfftc;

	/* allocate space */
	w = ealloc1complex(nf);
	a = ealloc1float(nfftc);
	p = ealloc1float(nfftc);
		
	memset( (void *) &a[nt], 0, (nfftc-nt)*FSIZE);
	memcpy( (void *) a, (const void *) x, nt*FSIZE);
		
	/* FFT */			
	sscal(nt,snfftc,a,1);
	pfarc(sign1, nfftc,a,w);
	

	for(iw=0;iw<nf;iw++) {
		a[iw] = rcabs(w[iw]);
		p[iw] = atan2(w[iw].i,w[iw].r);
	}
	
	for(iw=0;iw<nf;iw++) {
		if(!CLOSETO(a[iw],0.0)) {
			w[iw].r = (float)log((double)a[iw]);
			w[iw].i = 0.0;
		} else {
			w[iw].r=0.0;
			w[iw].i=0.0;
		}
	}
	pfacr(sign2, nfftc,w,c);

	if(mph) {

		a[0] = c[0];
		if(nt%2) {
			for(iw=1;iw<nt/2;iw++)
				a[iw] = 2.0*c[iw];
			a[nt/2] = c[nt/2];
			memset( (void *) &a[nt/2+1],0,(nt/2-1)*FSIZE);
		} else {
			for(iw=1;iw<nt/2;iw++)
				a[iw] = 2.0*c[iw];
			memset( (void *) &a[nt/2],0,(nt/2-1)*FSIZE);
		}
		
		memset( (void *) &a[nt], 0, (nfftc-nt)*FSIZE);

		sscal(nt,snfftc,a,1);
		pfarc(sign2, nfftc,a,w);
		
		for(iw=0;iw<nf;iw++)
			if(!CLOSETO(rcabs(w[iw]),0.0)) {
				w[iw] = cexp(w[iw]);
			} else {
				w[iw].r=0.0;
				w[iw].i=0.0;
			}
		
		pfacr(sign2, nfftc,w,c);
	}
	
	free1float(a);
	free1float(p);
	free1complex(w);
}

@


1.6
log
@copyright
@
text
@d71 3
@


1.5
log
@added sign1 and sign2 parameters, cleaned up the selfdoc and stuff
@
text
@d1 4
a4 1
/* SUCEPSTRUM: $Revision: 1.4 $ ; $Date: 2010/11/24 22:51:47 $	*/
@


1.4
log
@changed sym to centered to be consistent with other SU programs.
ls
@
text
@d1 1
a1 1
/* SUCEPSTRUM: $Revision: 1.3 $ ; $Date: 2009/07/28 17:19:20 $	*/
d19 2
d27 1
a27 1
" C(t) = IFFT(ln(|T(w)|)}						",
d46 1
a46 1
void rceps(int nt, int mph,float *x,float *c);
d48 2
a49 1
int main( int argc, char *argv[] )
d51 6
a56 4
	int nt;		/* number of time samples per trace */
	float dt;	/* time sampling interval	*/
	int centered;	/* flag; =1 symmetric output 	*/
	int mpr;
d64 3
a66 1
	if (!getparint("mpr", &mpr)) mpr=0;
d78 1
a78 1
			rceps(nt,mpr,tr.data,tr.data);	
d100 1
a100 1
	}while(gettr(&tr));
d102 1
a102 1
	return EXIT_SUCCESS;
d105 1
a105 1
void rceps(int nt, int mph,float *x,float *c)
d123 3
a125 3
	complex *w;
	float *a;
	float *p;
a128 1
	float fftpadd=50;
d131 1
a131 1
	ntp = NINT(nt*(1.0+fftpadd/100.0));
d137 2
d143 1
a143 1
	memset( (void *) &a[nt], (int) '\0', (nfftc-nt)*FSIZE);
d148 1
a148 1
	pfarc(-1, nfftc,a,w);
d165 1
a165 1
	pfacr(1, nfftc,w,c);
d174 1
a174 1
			memset( (void *) &a[nt/2+1],(int) '\0',(nt/2-1)*FSIZE);
d178 1
a178 1
			memset( (void *) &a[nt/2],(int) '\0',(nt/2-1)*FSIZE);
d181 1
a181 1
		memset( (void *) &a[nt], (int) '\0', (nfftc-nt)*FSIZE);
d184 1
a184 1
		pfarc(1, nfftc,a,w);
d194 1
a194 1
		pfacr(1, nfftc,w,c);
@


1.3
log
@selfdoc changes
@
text
@d1 1
a1 1
/* SUCEPSTRUM: $Revision: 1.2 $ ; $Date: 2009/07/22 17:41:35 $	*/
d19 3
a21 2
"   mpr=0   =1 minimum phase reconstructed version of original signal   ",
"   sym=0   1 symmetrical output				 	",
d32 1
a32 1
 *  c. 2008
d50 1
a50 1
	int sym;	/* flag; =1 symmetric output 	*/
d58 1
a58 1
	if (!getparint("sym", &sym)) sym=0;
d69 2
d73 2
a74 1
			if(sym) {
d83 2
a84 1
					for(it=0;it<n/2;it++) trout.data[it] = tr.data[n/2-it];
@


1.2
log
@small cosmetic changes
@
text
@d1 1
a1 1
/* SUCEPSTRUM: $Revision: 1.19 $ ; $Date: 2006/11/07 22:58:42 $	*/
a2 3
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
a3 1
#include <sys/file.h>
d6 1
a6 1
#define tpi 2.0*3.1415926535897 
d12 3
a14 3
" SUCEPSTRUM - Compute the CEPSTRUM of a seismic trace			",
"									",
" sucepstrum < stdin > stdout					   	",
d19 1
a19 1
"   mpr=0   0 minimum phase reconstructed version of original signal    ",
a20 1
"									",
d26 1
a26 1
"									",
d47 3
a49 4
	int nt;
	float dt;
	int sym;
	int inv;
d52 1
d56 1
a57 1
	if (!getparint("inv", &inv)) inv=0;
d65 1
@


1.1
log
@Initial revision
@
text
@d1 1
d16 7
a22 10
" SUCEPSTRUM - Compute the cepstrum of a seismic trace                  ",
"                                                                       ",
" sucepstrum < stdin > stdout                                           ",
"                                                                       ",
" Required parameters:                                                  ",
"        none                                                           ",
"                                                                       ",
" Optional parameters:                                                  ",
"                                                                       ",
"                                                                       ",
d24 8
a31 5
"   sym=0   1 symetrical output                                         ",
"                                                                       ",
" C(t) = FFT-1{ln(|T(w)|)}                                              ",
"        |T(w)| = amplitude spectrum of the trace                       ",
"                                                                       ",
d35 2
a36 2
 * Author: Balazs Nemeth of Potash Corporation of Saskatchewan Inc. 2008
 *
d41 2
a42 2
#define LOOKFAC 4       /* Look ahead factor for npfaro   */
#define PFA_MAX 720720  /* Largest allowed nfft           */
d44 1
a44 1
/* Segy data constans */
d66 2
a67 2
        if (!gettr(&tr)) err("can't get first trace");
        nt = tr.ns;
d98 13
d126 3
a128 3
        if (nfftc >= SU_NFLTS || nfftc >= PFA_MAX)
               	err("Padded nt=%d--too big", nfftc);
        nf = nfftc/2 + 1;
@
