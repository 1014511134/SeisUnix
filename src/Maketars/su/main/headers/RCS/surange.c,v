head	1.18;
access;
symbols;
locks; strict;
comment	@ * @;


1.18
date	2011.11.16.22.10.29;	author john;	state Exp;
branches;
next	1.17;

1.17
date	2011.11.12.00.13.49;	author john;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.19.23.11.02;	author john;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.07.22.58.42;	author john;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.04.17.04.04;	author john;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.04.16.42.43;	author john;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.11;

1.11
date	96.09.13.21.49.05;	author john;	state Exp;
branches;
next	1.10;

1.10
date	95.08.04.20.46.55;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	95.01.19.11.44.14;	author john;	state Exp;
branches;
next	1.8;

1.8
date	94.08.25.15.00.40;	author jkc;	state Exp;
branches;
next	1.7;

1.7
date	93.11.24.15.58.20;	author john;	state Exp;
branches;
next	1.6;

1.6
date	93.08.09.15.19.51;	author john;	state Exp;
branches;
next	1.5;

1.5
date	92.10.26.11.30.21;	author john;	state Exp;
branches;
next	1.4;

1.4
date	91.09.05.08.51.40;	author jkcohen;	state Exp;
branches;
next	1.3;

1.3
date	90.12.20.09.18.55;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.09.03.09.53.09;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.04.20.15.25.58;	author jkc;	state Exp;
branches;
next	;


desc
@Give amax and min of non-zero header words
@


1.18
log
@added Reg Beardsley's checkpar() call
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SURANGE: $Revision: 1.16 $ ; $Date: 2008/08/19 23:11:02 $  */

#include "su.h"
#include "segy.h"
#include "header.h"
#include <signal.h>

/*********************** self documentation **********************/
char *sdoc[] = {
" 								",
" SURANGE - get max and min values for non-zero header entries	",
" 								",
" surange <stdin	 					",
"								",
" Optional parameters:						",
"	key=		Header key(s) to range (default=all)	",
" 								",
" Note: Gives partial results if interrupted			",
" 								",
" Output is: 							",
" number of traces 						",
" keyword min max (first - last) 				",
" 								",
NULL};

/* Credits:
 *	Geocon: Garry Perratt (output one header per line;
 *		option to specify headers to range;
 *		added first & last values where min<max)
 *	Based upon original by:
 *		SEP: Stew Levin
 *		CWP: Jack K. Cohen
 *
 * Note: the use of "signal" is inherited from BSD days and may
 *       break on some UNIXs.  It is dicy in that the responsibility
 *	 for program termination is lateraled back to the main.
 *
 */
/**************** end self doc ***********************************/


/* Prototypes */
void printrange(segy *tpmin, segy *tpmax, segy *tpfirst, segy *tplast);
static void closeinput(void);

segy tr, trmin, trmax, trfirst, trlast;

int
main(int argc, char **argv)
{
	int ntr;			/* number of traces		*/
	int nkeys=0;			/* number of keywords to range	*/
	Value val;			/* value of current keyword	*/
	Value valmin;			/* smallest seen so far		*/
	Value valmax;			/* largest seen so far		*/
	cwp_String type;		/* data type of keyword		*/
	cwp_String key[SU_NKEYS];	/* array of keywords		*/


	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);

	/* Get "key" value */
	if ((nkeys=countparval("key"))!=0) {
		getparstringarray("key",key);
	}

        checkpars();

	/* Zero out values of trmin and trmax */
	memset((void *) &trmin, 0, sizeof(segy));
	memset( (void *) &trmax, 0, sizeof(segy));

	/* Set up closing commands */
	signal(SIGINT, (void (*) (int)) closeinput);
	signal(SIGTERM, (void (*) (int)) closeinput);

	/* Do first trace outside loop to initialize mins and maxs */
	if (!gettr(&tr)) err("can't get first trace");
	{	register int i;
		if (nkeys==0) {
   			for (i = 0; i < SU_NKEYS; ++i) {
 				gethval(&tr, i, &val);
 				puthval(&trmin, i, &val);
 				puthval(&trmax, i, &val);
 				puthval(&trfirst, i, &val);
			}
		} else	{
			register int j;
			for (i=0;i<nkeys;i++) {
				j = getindex(key[i]);
 				gethval(&tr, j, &val);
 				puthval(&trmin, j, &val);
 				puthval(&trmax, j, &val);
 				puthval(&trfirst, j, &val);
			}
		}
	}

	ntr = 1;
	while (gettr(&tr)) {
		register int i;
		if (nkeys==0) {
	       		for (i = 0; i < SU_NKEYS; ++i) {
				type = hdtype(getkey(i));
				gethval(&tr, i, &val);
				gethval(&trmin, i, &valmin);
				gethval(&trmax, i, &valmax);
				if (valcmp(type, val, valmin) < 0)
					puthval(&trmin, i, &val);
				if (valcmp(type, val, valmax) > 0)
					puthval(&trmax, i, &val);
 				puthval(&trlast, i, &val);
			}
		} else	{
			register int j;
			for (i=0;i<nkeys;i++) {
				type = hdtype(key[i]);
				j = getindex(key[i]);
				gethval(&tr, j, &val);
				gethval(&trmin, j, &valmin);
				gethval(&trmax, j, &valmax);
				if (valcmp(type, val, valmin) < 0)
					puthval(&trmin, j, &val);
				if (valcmp(type, val, valmax) > 0)
					puthval(&trmax, j, &val);
 				puthval(&trlast, j, &val);

			}
		}
		++ntr;
	}

	printf("%d traces:\n",ntr);
	printrange(&trmin, &trmax, &trfirst, &trlast);


	return(CWP_Exit());
}



/* printrange - print non-zero header values ranges	*/
void printrange(segy *tpmin, segy *tpmax, segy *tpfirst, segy *tplast)
{
	register int i = 0;
	Value valmin, valmax, valfirst, vallast;
	double dvalmin, dvalmax, dvalfirst, dvallast;
	cwp_String key;
	cwp_String type;
	int kmin = 0, kmax=SU_NKEYS;

	for (i = kmin; i < kmax; ++i) {
		key = getkey(i);
		type = hdtype(key);
		gethval(tpmin, i, &valmin);
		gethval(tpmax, i, &valmax);
		gethval(tpfirst, i, &valfirst);
		gethval(tplast, i, &vallast);
		dvalmin = vtod(type, valmin);
		dvalmax = vtod(type, valmax);
		dvalfirst = vtod(type, valfirst);
		dvallast = vtod(type, vallast);
		if (dvalmin || dvalmax) {
			if (dvalmin < dvalmax) {
				printf("%-8s ", key);
				printfval(type, valmin);
				printf(" ");
				printfval(type, valmax);
				printf(" (");
				printfval(type, valfirst);
				printf(" - ");
				printfval(type, vallast);
				printf(")");
			} else {
				printf("%-8s ", key);
				printfval(type, valmin);
			}
			putchar('\n');
		}
	}
	return;
}


static void closeinput(void) /* for graceful interrupt termination */
{
	/* Close stdin and open /dev/null in its place.  Now we are reading */
	/* from an empty file and the loops terminate in a normal fashion.  */

	efreopen("/dev/null", "r", stdin);
}
@


1.17
log
@copyright
@
text
@d72 2
@


1.16
log
@put in output
in selfdoc
@
text
@d1 4
a4 1
/* SURANGE: $Revision: 1.15 $ ; $Date: 2006/11/07 22:58:42 $  */
@


1.15
log
@changed    memset( .., (int) '\0',...) to memset( .., 0,..) as per suggestion of Marion Zhu and Reg Beardsley
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.14 $ ; $Date: 2005/10/04 17:04:04 $  */
d20 4
@


1.14
log
@Garry Parratt's with number of traces put back in
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.13 $ ; $Date: 2005/10/04 16:42:43 $  */
d66 2
a67 2
	memset((void *) &trmin, (int) '\0', sizeof(segy));
	memset( (void *) &trmax, (int) '\0', sizeof(segy));
@


1.13
log
@4 Oct 2005
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.12 $ ; $Date: 2003/06/09 16:17:07 $  */
d129 1
@


1.12
log
@9 June 2003
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.11 $ ; $Date: 1996/09/13 21:49:05 $	*/
d14 3
d18 1
a18 1
" Note: gives partial results if interrupted			",
d23 6
a28 2
 *	SEP: Stew
 *	CWP: Jack
d39 1
a39 1
void printrange(segy *tpmin, segy *tpmax);
d42 1
a42 1
segy tr, trmin, trmax;
d47 7
a53 5
	int ntr;		/* number of traces		*/
	Value val;		/* value of current keyword	*/
	Value valmin;		/* smallest seen so far		*/
	Value valmax;		/* largest seen so far		*/
	cwp_String type;	/* data type of keyword		*/
d60 4
d65 1
d68 2
d75 18
a92 6
	{ register int i;
	  for (i = 0; i < SU_NKEYS; ++i) {
		gethval(&tr, i, &val);
		puthval(&trmin, i, &val);
		puthval(&trmax, i, &val);
	  }
a94 1

d98 27
a124 9
	        for (i = 0; i < SU_NKEYS; ++i) {
			type = hdtype(getkey(i));
			gethval(&tr, i, &val);
			gethval(&trmin, i, &valmin);
			gethval(&trmax, i, &valmax);
			if (valcmp(type, val, valmin) < 0)
				puthval(&trmin, i, &val);
			if (valcmp(type, val, valmax) > 0)
				puthval(&trmax, i, &val);
d129 1
a129 2
	printf("%d traces:\n", ntr);
	printrange(&trmin, &trmax);
d138 1
a138 1
void printrange(segy *tpmin, segy *tpmax)
d140 3
a142 3
	register int i, j = 0;
	Value valmin, valmax;
	double dvalmin, dvalmax;
d145 1
d147 1
a147 1
	for (i = 0; i < SU_NKEYS; ++i) {
d152 2
d156 2
d160 1
a160 1
				printf(" %s=(", key);
d162 1
a162 1
				putchar(',');
d164 5
a168 1
				printf(") ");
d170 1
a170 1
				printf(" %s=", key);
d173 1
a173 2
			if ((++j % 5) == 0)
				putchar('\n');
a175 1
	putchar('\n');
@


1.11
log
@silenced -Wall messages
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.10 $ ; $Date: 1995/08/04 20:46:55 $	*/
d88 1
a88 1
	return EXIT_SUCCESS;
@


1.10
log
@Changed casts in signal() calls per Stew Levin
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.9 $ ; $Date: 1995/01/19 11:44:14 $	*/
d37 1
@


1.9
log
@fixed unmached comments
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.8 $ ; $Date: 94/08/25 15:00:40 $	*/
d53 2
a54 2
	signal(SIGINT, (void *) closeinput);
	signal(SIGTERM, (void *) closeinput);
@


1.8
log
@Removed copyright statement from codes that had it.
Moved self-doc line for sudoc.
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.7 $ ; $Date: 93/11/24 15:58:20 $	*/
d130 1
a130 1
	/* Close stdin and open /dev/null in its place.  Now we are reading
d132 1
@


1.7
log
@changed bzero to memset
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.6 $ ; $Date: 93/08/09 15:19:51 $	*/
a2 13
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1990.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado.edu)
 *----------------------------------------------------------------------
 */

a17 1
/**************** end self doc ***********************************/
d28 1
d43 1
a43 1
	cwp_String type;		/* data type of keyword		*/
@


1.6
log
@changed String to cwp_String
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.5 $ ; $Date: 92/10/26 11:30:21 $	*/
d64 2
a65 2
	bzero(&trmin, sizeof(segy));
	bzero(&trmax, sizeof(segy));
@


1.5
log
@new selfdoc installed
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.4 $ ; $Date: 91/09/05 08:51:40 $	*/
d56 1
a56 1
	String type;		/* data type of keyword		*/
d111 2
a112 2
	String key;
	String type;
@


1.4
log
@string -> String and so forth
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.3 $ ; $Date: 90/12/20 09:18:55 $	*/
d22 9
a30 9
String sdoc =
" 								\n"
" SURANGE - get max and min values for non-zero header entries	\n"
" 								\n"
" surange <stdin	 					\n"
" 								\n"
" Note: gives partial results if interrupted			\n"
" 								\n"
;
d61 1
a61 1
	askdoc(1);
@


1.3
log
@Tweak use of signal to make ansi c happy;
update style.
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.2 $ ; $Date: 90/09/03 09:53:09 $	*/
d22 1
a22 1
string sdoc =
d53 4
a56 4
	value val;		/* value of current keyword	*/
	value valmin;		/* smallest seen so far		*/
	value valmax;		/* largest seen so far		*/
	string type;		/* data type of keyword		*/
d109 1
a109 1
	value valmin, valmax;
d111 2
a112 2
	string key;
	string type;
@


1.2
log
@ANSI C changes and z -> d for doubles
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 1.1 $ ; $Date: 90/04/20 15:25:58 $	*/
d22 9
a30 9
string sdoc = "\
								\n\
SURANGE - get max and min values for non-zero header entries	\n\
								\n\
surange <stdin		 					\n\
								\n\
Note: gives partial results if interrupted			\n\
								\n\
";
d37 4
d44 4
a52 1
	int i;			/* counter over indices		*/
a56 2
	void printrange();	/* print range values		*/
	int closein();		/* catch interrupt 		*/
d66 2
a67 2
	signal(SIGINT, closein);
	signal(SIGTERM, closein);
d71 2
a72 1
	for (i = 0; i < SU_NKEYS; i++) {
d76 1
d82 2
a83 1
	        for (i = 0; i < SU_NKEYS; i++) {
d93 1
a93 1
		ntr++;
d106 1
a106 2
void printrange(tpmin, tpmax)
segy *tpmin, *tpmax;
d108 1
a108 1
	int i, j = 0;
d114 1
a114 1
	for (i = 0; i < SU_NKEYS; i++) {
d141 1
a141 1
static int closein(void) /* for graceful interrupt termination */
d143 2
a144 3
	/* Close stdin and open /dev/null in its place.  Now we are */
	/* reading from an empty file and the loops terminate in a  */
	/* normal fashion.  (Stew dropped this here w/o comment.)   */
a145 1
	return EXIT_FAILURE;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SURANGE: $Revision: 2.6 $ ; $Date: 89/05/25 16:53:31 $	*/
d12 1
a12 1
 *  Golden, CO 80401  (isis!csm9a!jkcohen)
a36 1
 *
a38 5
/* Embed Revision Control System identifier strings */
static string progid =
	"   $Source: /src/su/src/RCS/surange.c,v $";
static string revid =
	"   $Revision: 2.6 $ ; $Date: 89/05/25 16:53:31 $";
a39 2


d42 1
a42 2
main(argc, argv)
int argc; char **argv;
a55 5
	if (!igetpar("ID", &ID))	ID = 0;
	if (ID) {
		(void) fprintf(stderr, "%s\n", progid);
		(void) fprintf(stderr, "%s\n", revid);
	}
d103 1
a103 1
	double zvalmin, zvalmax;
d112 4
a115 4
		zvalmin = vtoz(type, valmin);
		zvalmax = vtoz(type, valmax);
		if (zvalmin || zvalmax) {
			if (zvalmin < zvalmax) {
d134 1
a134 1
static int closein() /* for graceful interrupt termination */
d139 2
a140 2
	freopen("/dev/null", "r", stdin);
	return -1;
@
