head     1.3;
branch   ;
access   jkc;
symbols  ;
locks    ; strict;
comment  @@;


1.3
date     94.03.01.10.44.12;  author john;  state Exp;
branches ;
next     1.2;

1.2
date     94.03.01.10.27.16;  author john;  state Exp;
branches ;
next     1.1;

1.1
date     94.03.01.10.19.27;  author john;  state Exp;
branches ;
next     ;


desc
@abel.3 --- man page for abel transform
@


1.3
log
@small changes.
@
text
@.TH ABEL 3CWP CWP
.UC 4
.SH NAME
abel, abelalloc, abelfree \- compute the discrete Abel transform 
of a function
.SH SYNOPSIS
.nf
.B #include """cwp.h"""
.PP
.B "void abel (void *at, float f[], float g[])"
.PP
.B "void *abelalloc (int n)"
.PP
.B "void abelfree (void *at)"
.PP
.fi

.SH DESCRIPTION
.I Abel
computes the Abel transform
.PP
.I Abelalloc
allocates and returns a (void) pointer to an Abel transformer
.PP
.I Abelfree
frees an Abel transformer.
.PP
.PP
These routines are contained in the package .../cwp/lib/abel.c.
.P
The
.I Abel
transform is defined by:
.na
.nf

                 Infinity
        g(y) = 2 Integral dx f(x)/sqrt(1-(y/x)^2)
                   |y|

.fi
.ad
Linear interpolation is used to define the continuous function f(x)
corresponding to the samples in f[].  The first sample f[0] corresponds
to f(x=0) and the sampling interval is assumed to be 1.  Therefore, the
input samples correspond to 0 <= x <= n-1.  Samples of f(x) for x > n-1
are assumed to be zero.  These conventions imply that 
.na
.nf

        g[0] = f[0] + 2*f[1] + 2*f[2] + ... + 2*f[n-1].

.fi
.ad

.SH PARAMETERS
.TP 8
.I n
is the number of samples to transform
.TP 8
.I at
is a void pointer returned by abelalloc(int n)
.TP 8
.I f[]
is the input function being transformed
.TP 8
.I g[]
is the output of the Abel transform

.SH RETURN VALUE
.I Abelalloc
returns a (void) pointer 
.I *at
to an Abel transformer
.PP
.I Abel
returns the array 
.I g[]
of Abel transformed values.

.SH USAGE EXAMPLE
.na
.nf
        int i,n=N;
        float f[N],g[N],e[N],k,dk;
        void *at;

        at = abelalloc(n);
        abel(at,f,g);
        for (i=0,k=0.0; i<n; ++i,k+=dk) {
                g[i] = ...
			...
        }
        abelfree(at);
.fi
.ad
.SH REFERENCES
References:
Hansen, E. W., 1985, Fast Hankel transform algorithm:  IEEE Trans. on
Acoustics, Speech and Signal Processing, v. ASSP-33, n. 3, p. 666-671.
(Beware of several errors in the equations in this paper!)

.SH SEE ALSO
hankel(3CWP)
.SH AUTHORS
Lydia Deng and Dave Hale.
.SH REVISION LEVEL
1.2 (92/06/11)

@


1.2
log
@minor cosmetic revisions.
@
text
@d4 2
a5 2
abel, abelalloc, abelfree 
\- compute the discrete Abel transform 
d19 1
a19 1
.I abel
d22 1
a22 1
.I abelalloc
d25 2
a26 2
.I abelfree
frees an Abel transformer
d28 1
d32 1
a32 1
.I abel
d85 1
a85 1
        float f[N],g[N],e[N],a,r,k,dr,dk;
a87 6
        a = 1.0;
        dr = dk = 1.0/n;

        for (i=0,r=0.0; i<n; ++i,r+=dr) {
                f[i] = a-r;
        }
d91 2
a92 2
                g[i] *= dr;
                e[i] = (k!=0.0 ? a*sqrt(a*a-k*k)-k*k*acosh(a/k) : a*a);
a94 4
        fwrite(g,sizeof(float),n,stdout);
        fwrite(e,sizeof(float),n,stdout);


@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
compute the Abel transform
d23 1
a23 1
allocate and return a pointer to an Abel transformer
d26 1
a26 1
free an Abel transformer
d32 1
a32 1
is defined by:
d59 1
a59 1
.PP
d62 1
a62 1
.PP
d65 1
a65 1
.PP
d70 9
a78 3
The
.I abelalloc
returns a pointer to an Abel transformer
@
