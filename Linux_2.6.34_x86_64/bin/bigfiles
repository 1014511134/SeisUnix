#! /bin/sh
# bigfiles - show large files in current tree
# Usage: bigfiles [size]
# Modified from Jack K. Cohen's original 1988 script by Craig Artley, 1992.

cmd=`basename $0`

case $# in
	0) find . -type f -size +1000 -exec ls -s {} \; ;;
	1) find . -type f -size +$1 -exec ls -s {} \; ;;
	*) echo "$cmd [size_in_blocks]" 1>&2 ; exit 1
esac

find . -type d -size +5 -exec ls -ld {} \;

exit 0

# The above find command spawns an ls process for every bigfile found.
# As a result, bigfiles are listed on the fly as they are found.
# This makes it faster than the original when a few files are found, but
# somewhat slower when a large number of files are found.
#
# The orginal script passed the bigfiles onto xargs, which listed them
# with a single call to ls.  It requires the MARKER_FILE kludge, and 
# no files are listed until the entire job is finished.
#
# Here is Jack's original script:
#! /bin/sh
# bigfiles - show large files in current tree
# Usage: bigfiles [size]
# Jack K. Cohen, 1988
#
# Bug: all this damn ___MARKER_FILE stuff is because if find comes up
#      ls will list everything in the current directory!

cmd=`basename $0`
tmp=___MARKER_FILE

# Arrange to remove tmp at shell termination (0) or signal
# Internal trap to ignore 0 is to avoid double remove in case of signal
trap "rm -f $tmp; trap '' 0; exit 1" 0 1 2 3 15


touch ___MARKER_FILE
case $# in
0)
	(find . -type f -size +1000 -print ; echo ___MARKER_FILE) | xargs ls -s
;;
1)
	(find . -type f -size +$1 -print ; echo ___MARKER_FILE) | xargs ls -s
;;
*)
	echo "$cmd [size_in_blocks]" 1>&2 ; exit 1
esac
(find . -type d -size +5 -print ; echo ___MARKER_FILE) | xargs ls -ld

exit 0
